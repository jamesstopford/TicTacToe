<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TicTacToe - Game Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #e0e0e0;
        }
        h1 {
            color: #00ffff;
        }
        h2 {
            color: #ff00ff;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: rgba(0, 255, 0, 0.1);
            border-left: 4px solid #00ff00;
        }
        .test-fail {
            background: rgba(255, 0, 0, 0.1);
            border-left: 4px solid #ff3333;
        }
        .summary {
            padding: 20px;
            margin-top: 20px;
            background: #12121a;
            border-radius: 4px;
        }
        .summary.all-pass {
            border: 2px solid #00ff00;
        }
        .summary.has-failures {
            border: 2px solid #ff3333;
        }
        .stats {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>TicTacToe Test Suite</h1>
    <div id="test-results"></div>
    <div id="summary" class="summary"></div>

    <!-- Load game modules -->
    <script src="../js/storage.js"></script>
    <script src="../js/game.js"></script>
    <script src="../js/ai.js"></script>

    <script>
        // Simple test framework
        const TestRunner = {
            results: [],
            currentSuite: '',

            suite(name) {
                this.currentSuite = name;
            },

            test(description, fn) {
                try {
                    fn();
                    this.results.push({
                        suite: this.currentSuite,
                        description,
                        passed: true
                    });
                } catch (error) {
                    this.results.push({
                        suite: this.currentSuite,
                        description,
                        passed: false,
                        error: error.message
                    });
                }
            },

            assertEqual(actual, expected, message = '') {
                if (actual !== expected) {
                    throw new Error(
                        `${message ? message + ': ' : ''}Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`
                    );
                }
            },

            assertDeepEqual(actual, expected, message = '') {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(
                        `${message ? message + ': ' : ''}Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`
                    );
                }
            },

            assertTrue(value, message = '') {
                if (!value) {
                    throw new Error(message || 'Expected true, got false');
                }
            },

            assertFalse(value, message = '') {
                if (value) {
                    throw new Error(message || 'Expected false, got true');
                }
            },

            assertNotNull(value, message = '') {
                if (value === null || value === undefined) {
                    throw new Error(message || 'Expected non-null value');
                }
            },

            render() {
                const container = document.getElementById('test-results');
                const summary = document.getElementById('summary');

                // Group by suite
                const suites = {};
                this.results.forEach(r => {
                    if (!suites[r.suite]) {
                        suites[r.suite] = [];
                    }
                    suites[r.suite].push(r);
                });

                // Render results
                let html = '';
                for (const [suite, tests] of Object.entries(suites)) {
                    html += `<h2>${suite}</h2>`;
                    tests.forEach(t => {
                        const status = t.passed ? 'pass' : 'fail';
                        const icon = t.passed ? '✓' : '✗';
                        html += `<div class="test-result test-${status}">
                            <strong>${icon}</strong> ${t.description}
                            ${t.error ? `<br><code>${t.error}</code>` : ''}
                        </div>`;
                    });
                }
                container.innerHTML = html;

                // Render summary
                const passed = this.results.filter(r => r.passed).length;
                const failed = this.results.filter(r => !r.passed).length;
                const total = this.results.length;

                summary.className = `summary ${failed > 0 ? 'has-failures' : 'all-pass'}`;
                summary.innerHTML = `
                    <div class="stats">
                        <strong>Results:</strong> ${passed}/${total} tests passed
                    </div>
                    ${failed > 0 ? `<div style="color: #ff3333">${failed} test(s) failed</div>` : '<div style="color: #00ff00">All tests passed!</div>'}
                `;
            }
        };

        // Aliases for convenience
        const { suite, test, assertEqual, assertDeepEqual, assertTrue, assertFalse, assertNotNull } = TestRunner;

        // ============================================================
        // GAME MODULE TESTS
        // ============================================================

        TestRunner.suite('Game Module - Initialization');

        TestRunner.test('Game initializes with empty board', () => {
            Game.init();
            const state = Game.getState();
            TestRunner.assertDeepEqual(state.board, ['', '', '', '', '', '', '', '', '']);
        });

        TestRunner.test('Game starts with player X by default', () => {
            Game.init(false);
            TestRunner.assertEqual(Game.getCurrentPlayer(), 'X');
        });

        TestRunner.test('Game can start with AI (O) first', () => {
            Game.init(true);
            TestRunner.assertEqual(Game.getCurrentPlayer(), 'O');
        });

        TestRunner.test('Game is not over at start', () => {
            Game.init();
            TestRunner.assertFalse(Game.isGameOver());
        });

        // ============================================================

        TestRunner.suite('Game Module - Move Handling');

        TestRunner.test('Valid move is accepted', () => {
            Game.init();
            const result = Game.makeMove(0);
            TestRunner.assertTrue(result);
        });

        TestRunner.test('Move places correct mark on board', () => {
            Game.init();
            Game.makeMove(4);
            const board = Game.getBoard();
            TestRunner.assertEqual(board[4], 'X');
        });

        TestRunner.test('Player switches after move', () => {
            Game.init();
            Game.makeMove(0);
            TestRunner.assertEqual(Game.getCurrentPlayer(), 'O');
        });

        TestRunner.test('Invalid move to occupied cell is rejected', () => {
            Game.init();
            Game.makeMove(0);
            const result = Game.makeMove(0);
            TestRunner.assertFalse(result);
        });

        TestRunner.test('Invalid move out of bounds is rejected', () => {
            Game.init();
            TestRunner.assertFalse(Game.isValidMove(-1));
            TestRunner.assertFalse(Game.isValidMove(9));
        });

        TestRunner.test('getAvailableMoves returns empty cells', () => {
            Game.init();
            Game.makeMove(0);
            Game.makeMove(4);
            const available = Game.getAvailableMoves();
            TestRunner.assertEqual(available.length, 7);
            TestRunner.assertFalse(available.includes(0));
            TestRunner.assertFalse(available.includes(4));
        });

        // ============================================================

        TestRunner.suite('Game Module - Win Detection');

        TestRunner.test('Detects horizontal win (top row)', () => {
            Game.init();
            // X | X | X
            // O | O | -
            // - | - | -
            Game.makeMove(0); // X
            Game.makeMove(3); // O
            Game.makeMove(1); // X
            Game.makeMove(4); // O
            Game.makeMove(2); // X wins
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'X');
            TestRunner.assertDeepEqual(state.winningLine, [0, 1, 2]);
        });

        TestRunner.test('Detects horizontal win (middle row)', () => {
            Game.init();
            // X | - | -
            // O | O | O
            // X | X | -
            Game.makeMove(0); // X
            Game.makeMove(3); // O
            Game.makeMove(6); // X
            Game.makeMove(4); // O
            Game.makeMove(7); // X
            Game.makeMove(5); // O wins
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'O');
            TestRunner.assertDeepEqual(state.winningLine, [3, 4, 5]);
        });

        TestRunner.test('Detects vertical win (left column)', () => {
            Game.init();
            // X | O | -
            // X | O | -
            // X | - | -
            Game.makeMove(0); // X
            Game.makeMove(1); // O
            Game.makeMove(3); // X
            Game.makeMove(4); // O
            Game.makeMove(6); // X wins
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'X');
            TestRunner.assertDeepEqual(state.winningLine, [0, 3, 6]);
        });

        TestRunner.test('Detects diagonal win (top-left to bottom-right)', () => {
            Game.init();
            // X | O | -
            // O | X | -
            // - | - | X
            Game.makeMove(0); // X
            Game.makeMove(1); // O
            Game.makeMove(4); // X
            Game.makeMove(3); // O
            Game.makeMove(8); // X wins
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'X');
            TestRunner.assertDeepEqual(state.winningLine, [0, 4, 8]);
        });

        TestRunner.test('Detects diagonal win (top-right to bottom-left)', () => {
            Game.init();
            // O | - | X
            // O | X | -
            // X | - | -
            Game.makeMove(2); // X
            Game.makeMove(0); // O
            Game.makeMove(4); // X
            Game.makeMove(3); // O
            Game.makeMove(6); // X wins
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'X');
            TestRunner.assertDeepEqual(state.winningLine, [2, 4, 6]);
        });

        // ============================================================

        TestRunner.suite('Game Module - Draw Detection');

        TestRunner.test('Detects draw when board is full', () => {
            Game.init();
            // X | O | X
            // X | O | O
            // O | X | X
            Game.makeMove(0); // X
            Game.makeMove(1); // O
            Game.makeMove(2); // X
            Game.makeMove(4); // O
            Game.makeMove(3); // X
            Game.makeMove(5); // O
            Game.makeMove(7); // X
            Game.makeMove(6); // O
            Game.makeMove(8); // X - Draw
            const state = Game.getState();
            TestRunner.assertTrue(state.gameOver);
            TestRunner.assertEqual(state.winner, 'draw');
            TestRunner.assertEqual(state.winningLine, null);
        });

        // ============================================================
        // AI MODULE TESTS
        // ============================================================

        TestRunner.suite('AI Module - Basic Functionality');

        TestRunner.test('AI returns a valid move', () => {
            const board = ['', '', '', '', '', '', '', '', ''];
            const move = AI.getMove(board);
            TestRunner.assertTrue(move >= 0 && move <= 8);
        });

        TestRunner.test('AI returns null when no moves available', () => {
            const board = ['X', 'O', 'X', 'X', 'O', 'O', 'O', 'X', 'X'];
            const move = AI.getMove(board);
            TestRunner.assertEqual(move, null);
        });

        TestRunner.test('AI chooses winning move when available', () => {
            // O | O | -
            // X | X | -
            // - | - | -
            const board = ['O', 'O', '', 'X', 'X', '', '', '', ''];
            const move = AI.getMove(board);
            TestRunner.assertEqual(move, 2); // AI should complete the win
        });

        TestRunner.test('AI blocks opponent winning move', () => {
            // X | X | -
            // O | - | -
            // - | - | -
            const board = ['X', 'X', '', 'O', '', '', '', '', ''];
            const move = AI.getMove(board);
            TestRunner.assertEqual(move, 2); // AI should block X from winning
        });

        // ============================================================

        TestRunner.suite('AI Module - Unbeatable Verification');

        TestRunner.test('AI never loses when going first (100 games)', () => {
            let aiLosses = 0;

            for (let game = 0; game < 100; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                let currentPlayer = 'O'; // AI goes first

                while (true) {
                    if (currentPlayer === 'O') {
                        const move = AI.getMove(board);
                        if (move === null) break;
                        board[move] = 'O';
                    } else {
                        // Human makes random move
                        const empty = [];
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') empty.push(i);
                        }
                        if (empty.length === 0) break;
                        const randomMove = empty[Math.floor(Math.random() * empty.length)];
                        board[randomMove] = 'X';
                    }

                    // Check for winner
                    const winner = AI.checkWinner(board);
                    if (winner === 'X') {
                        aiLosses++;
                        break;
                    }
                    if (winner === 'O' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'O' ? 'X' : 'O';
                }
            }

            TestRunner.assertEqual(aiLosses, 0, 'AI should never lose');
        });

        TestRunner.test('AI never loses when going second (100 games)', () => {
            let aiLosses = 0;

            for (let game = 0; game < 100; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                let currentPlayer = 'X'; // Human goes first

                while (true) {
                    if (currentPlayer === 'O') {
                        const move = AI.getMove(board);
                        if (move === null) break;
                        board[move] = 'O';
                    } else {
                        // Human makes random move
                        const empty = [];
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') empty.push(i);
                        }
                        if (empty.length === 0) break;
                        const randomMove = empty[Math.floor(Math.random() * empty.length)];
                        board[randomMove] = 'X';
                    }

                    // Check for winner
                    const winner = AI.checkWinner(board);
                    if (winner === 'X') {
                        aiLosses++;
                        break;
                    }
                    if (winner === 'O' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'O' ? 'X' : 'O';
                }
            }

            TestRunner.assertEqual(aiLosses, 0, 'AI should never lose');
        });

        // ============================================================

        TestRunner.suite('AI Module - Minimax Scoring');

        TestRunner.test('Minimax returns positive score for AI win', () => {
            // O | O | O
            // X | X | -
            // - | - | -
            const board = ['O', 'O', 'O', 'X', 'X', '', '', '', ''];
            const winner = AI.checkWinner(board);
            TestRunner.assertEqual(winner, 'O');
        });

        TestRunner.test('Minimax returns negative score for human win', () => {
            // X | X | X
            // O | O | -
            // - | - | -
            const board = ['X', 'X', 'X', 'O', 'O', '', '', '', ''];
            const winner = AI.checkWinner(board);
            TestRunner.assertEqual(winner, 'X');
        });

        // ============================================================

        TestRunner.suite('Storage Module');

        TestRunner.test('Storage loads default scores when none saved', () => {
            // Clear storage
            localStorage.removeItem('tictactoe_scores');
            const scores = Storage.loadScores();
            TestRunner.assertEqual(scores.wins, 0);
            TestRunner.assertEqual(scores.losses, 0);
            TestRunner.assertEqual(scores.draws, 0);
        });

        TestRunner.test('Storage saves and loads scores correctly', () => {
            const testScores = { wins: 5, losses: 3, draws: 2 };
            Storage.saveScores(testScores);
            const loaded = Storage.loadScores();
            TestRunner.assertEqual(loaded.wins, 5);
            TestRunner.assertEqual(loaded.losses, 3);
            TestRunner.assertEqual(loaded.draws, 2);
        });

        TestRunner.test('Storage resets scores to zero', () => {
            Storage.saveScores({ wins: 10, losses: 10, draws: 10 });
            const reset = Storage.resetScores();
            TestRunner.assertEqual(reset.wins, 0);
            TestRunner.assertEqual(reset.losses, 0);
            TestRunner.assertEqual(reset.draws, 0);
        });

        TestRunner.test('Storage saves and loads sound preference', () => {
            Storage.saveSoundEnabled(false);
            TestRunner.assertFalse(Storage.loadSoundEnabled());

            Storage.saveSoundEnabled(true);
            TestRunner.assertTrue(Storage.loadSoundEnabled());
        });

        // ============================================================

        TestRunner.suite('Storage Module - Difficulty');

        TestRunner.test('Storage loads default difficulty as hard when none saved', () => {
            localStorage.removeItem('tictactoe_difficulty');
            const difficulty = Storage.loadDifficulty();
            TestRunner.assertEqual(difficulty, 'hard');
        });

        TestRunner.test('Storage saves and loads easy difficulty correctly', () => {
            Storage.saveDifficulty('easy');
            const loaded = Storage.loadDifficulty();
            TestRunner.assertEqual(loaded, 'easy');
        });

        TestRunner.test('Storage saves and loads hard difficulty correctly', () => {
            Storage.saveDifficulty('hard');
            const loaded = Storage.loadDifficulty();
            TestRunner.assertEqual(loaded, 'hard');
        });

        TestRunner.test('Storage rejects invalid difficulty values', () => {
            // First set a valid value
            Storage.saveDifficulty('easy');

            // Try to save invalid value - should return false
            const result = Storage.saveDifficulty('invalid');
            TestRunner.assertFalse(result);

            // Value should remain 'easy' since invalid was rejected
            TestRunner.assertEqual(Storage.loadDifficulty(), 'easy');
        });

        TestRunner.test('Storage DIFFICULTY constants are exposed', () => {
            TestRunner.assertEqual(Storage.DIFFICULTY.EASY, 'easy');
            TestRunner.assertEqual(Storage.DIFFICULTY.HARD, 'hard');
        });

        // ============================================================

        TestRunner.suite('AI Module - Easy Mode');

        TestRunner.test('Easy AI returns a valid move', () => {
            const board = ['', '', '', '', '', '', '', '', ''];
            const move = AI.getEasyMove(board);
            TestRunner.assertTrue(move >= 0 && move <= 8);
        });

        TestRunner.test('Easy AI returns null when no moves available', () => {
            const board = ['X', 'O', 'X', 'X', 'O', 'O', 'O', 'X', 'X'];
            const move = AI.getEasyMove(board);
            TestRunner.assertEqual(move, null);
        });

        TestRunner.test('Easy AI only returns empty cell indices', () => {
            const board = ['X', 'O', '', 'X', 'O', '', '', '', 'X'];
            const emptyIndices = [2, 5, 6, 7];

            // Test multiple times since it is random
            for (let i = 0; i < 50; i++) {
                const move = AI.getEasyMove(board);
                TestRunner.assertTrue(
                    emptyIndices.includes(move),
                    `Move ${move} should be one of ${emptyIndices}`
                );
            }
        });

        TestRunner.test('findRandomMove returns different moves over many calls (randomness check)', () => {
            const board = ['', '', '', '', '', '', '', '', ''];
            const moveSet = new Set();

            // Call 100 times and collect unique moves
            for (let i = 0; i < 100; i++) {
                const move = AI.findRandomMove(board);
                moveSet.add(move);
            }

            // Should have gotten multiple different moves (statistically very likely)
            TestRunner.assertTrue(
                moveSet.size >= 3,
                `Expected multiple different moves, got ${moveSet.size} unique move(s)`
            );
        });

        TestRunner.test('getMoveWithDifficultyAndDelay returns move for easy difficulty', async () => {
            const board = ['', '', '', '', '', '', '', '', ''];
            const move = await AI.getMoveWithDifficultyAndDelay(board, 0, 'easy');
            TestRunner.assertTrue(move >= 0 && move <= 8);
        });

        TestRunner.test('getMoveWithDifficultyAndDelay returns move for hard difficulty', async () => {
            const board = ['', '', '', '', '', '', '', '', ''];
            const move = await AI.getMoveWithDifficultyAndDelay(board, 0, 'hard');
            TestRunner.assertTrue(move >= 0 && move <= 8);
        });

        TestRunner.test('Easy AI can be beaten (player can win in 50 games)', () => {
            // Simulate 50 games where player makes strategic moves against easy AI
            // Player should be able to win at least some games
            let playerWins = 0;

            for (let game = 0; game < 50; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                let currentPlayer = 'X';  // Player (X) goes first

                while (true) {
                    if (currentPlayer === 'X') {
                        // Player uses optimal strategy (minimax)
                        const move = AI.getMove(board);
                        if (move === null) break;
                        board[move] = 'X';
                    } else {
                        // Easy AI makes random move
                        const move = AI.getEasyMove(board);
                        if (move === null) break;
                        board[move] = 'O';
                    }

                    // Check for winner
                    const winner = AI.checkWinner(board);
                    if (winner === 'X') {
                        playerWins++;
                        break;
                    }
                    if (winner === 'O' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                }
            }

            // Player using optimal strategy against random AI should win frequently
            TestRunner.assertTrue(
                playerWins >= 10,
                `Player should win at least 10 games against easy AI, but won ${playerWins}`
            );
        });

        TestRunner.test('Hard AI vs Easy AI: Hard AI wins or draws all games', () => {
            // Simulate games where hard AI plays against easy AI
            // Hard AI should never lose
            let hardLosses = 0;

            for (let game = 0; game < 50; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                // Alternate who goes first
                let currentPlayer = game % 2 === 0 ? 'O' : 'X';  // O is hard AI, X is easy AI

                while (true) {
                    if (currentPlayer === 'O') {
                        // Hard AI
                        const move = AI.getMove(board);
                        if (move === null) break;
                        board[move] = 'O';
                    } else {
                        // Easy AI
                        const move = AI.getEasyMove(board);
                        if (move === null) break;
                        board[move] = 'X';
                    }

                    // Check for winner
                    const winner = AI.checkWinner(board);
                    if (winner === 'X') {
                        // Easy AI (X) beat Hard AI (O) - this is a loss for hard AI
                        hardLosses++;
                        break;
                    }
                    if (winner === 'O' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'O' ? 'X' : 'O';
                }
            }

            TestRunner.assertEqual(hardLosses, 0, 'Hard AI should never lose to easy AI');
        });

        // ============================================================

        TestRunner.suite('Storage Module - Player Symbol');

        TestRunner.test('Storage loads default player symbol as random when none saved', () => {
            localStorage.removeItem('tictactoe_player_symbol');
            const symbol = Storage.loadPlayerSymbol();
            TestRunner.assertEqual(symbol, 'random');
        });

        TestRunner.test('Storage saves and loads X symbol correctly', () => {
            Storage.savePlayerSymbol('X');
            const loaded = Storage.loadPlayerSymbol();
            TestRunner.assertEqual(loaded, 'X');
        });

        TestRunner.test('Storage saves and loads O symbol correctly', () => {
            Storage.savePlayerSymbol('O');
            const loaded = Storage.loadPlayerSymbol();
            TestRunner.assertEqual(loaded, 'O');
        });

        TestRunner.test('Storage saves and loads random symbol correctly', () => {
            Storage.savePlayerSymbol('random');
            const loaded = Storage.loadPlayerSymbol();
            TestRunner.assertEqual(loaded, 'random');
        });

        TestRunner.test('Storage rejects invalid symbol values', () => {
            // First set a valid value
            Storage.savePlayerSymbol('X');

            // Try to save invalid value - should return false
            const result = Storage.savePlayerSymbol('invalid');
            TestRunner.assertFalse(result);

            // Value should remain 'X' since invalid was rejected
            TestRunner.assertEqual(Storage.loadPlayerSymbol(), 'X');
        });

        TestRunner.test('Storage SYMBOL_CHOICE constants are exposed', () => {
            TestRunner.assertEqual(Storage.SYMBOL_CHOICE.X, 'X');
            TestRunner.assertEqual(Storage.SYMBOL_CHOICE.O, 'O');
            TestRunner.assertEqual(Storage.SYMBOL_CHOICE.RANDOM, 'random');
        });

        // ============================================================

        TestRunner.suite('Game Module - Player Symbol');

        TestRunner.test('Game initializes with player as X by default', () => {
            Game.init();
            TestRunner.assertEqual(Game.getPlayerSymbol(), 'X');
            TestRunner.assertEqual(Game.getAISymbol(), 'O');
        });

        TestRunner.test('Game initializes with player as O when specified', () => {
            Game.init('O');
            TestRunner.assertEqual(Game.getPlayerSymbol(), 'O');
            TestRunner.assertEqual(Game.getAISymbol(), 'X');
        });

        TestRunner.test('Game state includes playerSymbol and aiSymbol', () => {
            Game.init('O');
            const state = Game.getState();
            TestRunner.assertEqual(state.playerSymbol, 'O');
            TestRunner.assertEqual(state.aiSymbol, 'X');
        });

        TestRunner.test('X always goes first regardless of player symbol', () => {
            // When player is X
            Game.init('X');
            TestRunner.assertEqual(Game.getCurrentPlayer(), 'X');
            TestRunner.assertTrue(Game.isPlayerTurn());
            TestRunner.assertFalse(Game.isAITurn());

            // When player is O (AI is X)
            Game.init('O');
            TestRunner.assertEqual(Game.getCurrentPlayer(), 'X');
            TestRunner.assertFalse(Game.isPlayerTurn());  // It's AI's turn (X)
            TestRunner.assertTrue(Game.isAITurn());
        });

        TestRunner.test('isPlayerTurn works correctly when player is O', () => {
            Game.init('O');
            // X goes first, so AI (X) goes first
            TestRunner.assertFalse(Game.isPlayerTurn());
            TestRunner.assertTrue(Game.isAITurn());

            // Make a move as X (AI)
            Game.makeMove(0);
            // Now it should be O's (player's) turn
            TestRunner.assertTrue(Game.isPlayerTurn());
            TestRunner.assertFalse(Game.isAITurn());
        });

        TestRunner.test('Game handles invalid playerSymbol gracefully', () => {
            Game.init('invalid');
            // Should default to X
            TestRunner.assertEqual(Game.getPlayerSymbol(), 'X');
            TestRunner.assertEqual(Game.getAISymbol(), 'O');
        });

        // ============================================================

        TestRunner.suite('AI Module - Playing as X');

        TestRunner.test('findBestMoveForSymbol works for O (default behavior)', () => {
            const board = ['O', 'O', '', 'X', 'X', '', '', '', ''];
            const move = AI.findBestMoveForSymbol(board, 'O');
            TestRunner.assertEqual(move, 2); // Complete the win
        });

        TestRunner.test('findBestMoveForSymbol works for X', () => {
            // X | X | -
            // O | O | -
            // - | - | -
            const board = ['X', 'X', '', 'O', 'O', '', '', '', ''];
            const move = AI.findBestMoveForSymbol(board, 'X');
            TestRunner.assertEqual(move, 2); // X should complete the win at position 2
        });

        TestRunner.test('AI as X blocks opponent winning move', () => {
            // O | O | -
            // X | - | -
            // - | - | -
            const board = ['O', 'O', '', 'X', '', '', '', '', ''];
            const move = AI.findBestMoveForSymbol(board, 'X');
            TestRunner.assertEqual(move, 2); // X should block O from winning
        });

        TestRunner.test('AI as X never loses when going first (50 games)', () => {
            let aiLosses = 0;

            for (let game = 0; game < 50; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                let currentPlayer = 'X';  // AI (X) goes first

                while (true) {
                    if (currentPlayer === 'X') {
                        // AI plays as X using findBestMoveForSymbol
                        const move = AI.findBestMoveForSymbol(board, 'X');
                        if (move === null) break;
                        board[move] = 'X';
                    } else {
                        // Human (O) makes random move
                        const empty = [];
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') empty.push(i);
                        }
                        if (empty.length === 0) break;
                        const randomMove = empty[Math.floor(Math.random() * empty.length)];
                        board[randomMove] = 'O';
                    }

                    const winner = AI.checkWinner(board);
                    if (winner === 'O') {
                        aiLosses++;
                        break;
                    }
                    if (winner === 'X' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                }
            }

            TestRunner.assertEqual(aiLosses, 0, 'AI playing as X should never lose');
        });

        TestRunner.test('AI as X never loses when going second (50 games)', () => {
            let aiLosses = 0;

            for (let game = 0; game < 50; game++) {
                const board = ['', '', '', '', '', '', '', '', ''];
                let currentPlayer = 'O';  // Human (O) goes first... wait, X always goes first

                // Actually in TicTacToe, X always goes first.
                // If AI is X, AI goes first. Let's test AI as X going first,
                // and human making the first random move after AI.
                // Hmm, X always goes first in standard rules.

                // Let's test the scenario where human (O) somehow gets to move first
                // by having X already placed (simulating a mid-game state)
                // Actually, let's just test AI as X not losing in various scenarios

                // New approach: Human is O and moves first (non-standard but tests AI resilience)
                currentPlayer = 'O';

                while (true) {
                    if (currentPlayer === 'O') {
                        // Human (O) makes random move
                        const empty = [];
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') empty.push(i);
                        }
                        if (empty.length === 0) break;
                        const randomMove = empty[Math.floor(Math.random() * empty.length)];
                        board[randomMove] = 'O';
                    } else {
                        // AI plays as X
                        const move = AI.findBestMoveForSymbol(board, 'X');
                        if (move === null) break;
                        board[move] = 'X';
                    }

                    const winner = AI.checkWinner(board);
                    if (winner === 'O') {
                        aiLosses++;
                        break;
                    }
                    if (winner === 'X' || AI.isBoardFull(board)) {
                        break;
                    }

                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                }
            }

            TestRunner.assertEqual(aiLosses, 0, 'AI playing as X should never lose even when O moves first');
        });

        // ============================================================

        TestRunner.suite('Storage Module - Player Name');

        TestRunner.test('Storage loads empty string when no player name saved', () => {
            localStorage.removeItem('tictactoe_player_name');
            const name = Storage.loadPlayerName();
            TestRunner.assertEqual(name, '');
        });

        TestRunner.test('Storage saves and loads player name correctly', () => {
            Storage.savePlayerName('Alice');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, 'Alice');
        });

        TestRunner.test('Storage trims whitespace from player name', () => {
            Storage.savePlayerName('  Bob  ');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, 'Bob');
        });

        TestRunner.test('Storage limits player name to 30 characters', () => {
            const longName = 'A'.repeat(50);
            Storage.savePlayerName(longName);
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded.length, 30);
        });

        TestRunner.test('Storage sanitizes player name to prevent XSS', () => {
            Storage.savePlayerName('<script>alert("xss")</script>');
            const loaded = Storage.loadPlayerName();
            // Should not contain raw < or > characters
            TestRunner.assertFalse(loaded.includes('<'));
            TestRunner.assertFalse(loaded.includes('>'));
            // Should contain escaped versions
            TestRunner.assertTrue(loaded.includes('&lt;'));
            TestRunner.assertTrue(loaded.includes('&gt;'));
        });

        TestRunner.test('Storage sanitizes ampersand in player name', () => {
            Storage.savePlayerName('Rock & Roll');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, 'Rock &amp; Roll');
        });

        TestRunner.test('Storage sanitizes quotes in player name', () => {
            Storage.savePlayerName('He said "hello"');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertTrue(loaded.includes('&quot;'));
        });

        TestRunner.test('Storage sanitizes single quotes in player name', () => {
            Storage.savePlayerName("It's me");
            const loaded = Storage.loadPlayerName();
            TestRunner.assertTrue(loaded.includes('&#039;'));
        });

        TestRunner.test('clearPlayerName resets to empty string', () => {
            Storage.savePlayerName('TestUser');
            Storage.clearPlayerName();
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, '');
        });

        TestRunner.test('sanitizePlayerName returns empty string for non-string input', () => {
            TestRunner.assertEqual(Storage.sanitizePlayerName(null), '');
            TestRunner.assertEqual(Storage.sanitizePlayerName(undefined), '');
            TestRunner.assertEqual(Storage.sanitizePlayerName(123), '');
            TestRunner.assertEqual(Storage.sanitizePlayerName({}), '');
        });

        TestRunner.test('sanitizePlayerName handles normal names correctly', () => {
            TestRunner.assertEqual(Storage.sanitizePlayerName('John Doe'), 'John Doe');
            TestRunner.assertEqual(Storage.sanitizePlayerName('Player1'), 'Player1');
            TestRunner.assertEqual(Storage.sanitizePlayerName('X-Wing'), 'X-Wing');
        });

        TestRunner.test('PLAYER_NAME_MAX_LENGTH constant is exposed and equals 30', () => {
            TestRunner.assertEqual(Storage.PLAYER_NAME_MAX_LENGTH, 30);
        });

        TestRunner.test('Storage handles empty string player name', () => {
            Storage.savePlayerName('');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, '');
        });

        TestRunner.test('Storage handles whitespace-only player name as empty', () => {
            Storage.savePlayerName('   ');
            const loaded = Storage.loadPlayerName();
            TestRunner.assertEqual(loaded, '');
        });

        // ============================================================

        TestRunner.suite('Storage Module - Theme');

        TestRunner.test('Storage loads default theme as "default" when none saved', () => {
            localStorage.removeItem('tictactoe_theme');
            const theme = Storage.loadTheme();
            TestRunner.assertEqual(theme, 'default');
        });

        TestRunner.test('Storage saves and loads "default" theme correctly', () => {
            Storage.saveTheme('default');
            const loaded = Storage.loadTheme();
            TestRunner.assertEqual(loaded, 'default');
        });

        TestRunner.test('Storage saves and loads "terminal" theme correctly', () => {
            Storage.saveTheme('terminal');
            const loaded = Storage.loadTheme();
            TestRunner.assertEqual(loaded, 'terminal');
        });

        TestRunner.test('Storage rejects invalid theme values', () => {
            // First set a valid value
            Storage.saveTheme('default');

            // Try to save invalid value - should return false
            const result = Storage.saveTheme('invalid');
            TestRunner.assertFalse(result);

            // Value should remain 'default' since invalid was rejected
            TestRunner.assertEqual(Storage.loadTheme(), 'default');
        });

        TestRunner.test('Storage THEME constants are exposed', () => {
            TestRunner.assertEqual(Storage.THEME.DEFAULT, 'default');
            TestRunner.assertEqual(Storage.THEME.TERMINAL, 'terminal');
        });

        TestRunner.test('Storage handles corrupted theme value in localStorage', () => {
            // Directly set an invalid value in localStorage
            localStorage.setItem('tictactoe_theme', JSON.stringify('invalid_theme'));
            const theme = Storage.loadTheme();
            // Should fall back to default
            TestRunner.assertEqual(theme, 'default');
        });

        TestRunner.test('Theme can be changed multiple times', () => {
            Storage.saveTheme('default');
            TestRunner.assertEqual(Storage.loadTheme(), 'default');

            Storage.saveTheme('terminal');
            TestRunner.assertEqual(Storage.loadTheme(), 'terminal');

            Storage.saveTheme('default');
            TestRunner.assertEqual(Storage.loadTheme(), 'default');
        });

        // ============================================================

        // Run and render all tests
        TestRunner.render();
    </script>
</body>
</html>
